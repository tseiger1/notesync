{
  "version": 3,
  "sources": ["src/main.ts", "src/conversion/registry.ts", "src/conversion/pdfConverter.ts", "src/conversion/utils.ts", "src/conversion/noteStubConverter.ts", "src/logger.ts", "src/settings.ts", "src/llm/ollamaClient.ts", "src/llm/openaiClient.ts", "src/llm/index.ts", "src/history.ts"],
  "sourcesContent": ["import { Notice, Plugin } from 'obsidian';\nimport path from 'path';\nimport { existsSync } from 'fs';\nimport * as fs from 'fs/promises';\nimport chokidar, { FSWatcher } from 'chokidar';\nimport {\n  ConverterRegistry,\n  PdfConverter,\n  NoteStubConverter,\n  ensureDir,\n  ConvertedImage,\n  ConversionContext,\n} from './conversion';\nimport { StatusLogger } from './logger';\nimport {\n  DEFAULT_SETTINGS,\n  NoteSyncSettings,\n  NoteSyncSettingTab,\n} from './settings';\nimport {\n  createLLMClient,\n  EncodedImage,\n  LLMClient,\n  LLMGenerationContext,\n} from './llm';\nimport { FileSignature, ProcessingHistory } from './history';\n\nexport default class NoteSyncPlugin extends Plugin {\n  settings: NoteSyncSettings = DEFAULT_SETTINGS;\n  private watcher?: FSWatcher;\n  private readonly logger = new StatusLogger();\n  private readonly queue = new Set<string>();\n  private processing = false;\n  private statusBarItem?: HTMLElement;\n  private converterRegistry = new ConverterRegistry([\n    new PdfConverter(),\n    new NoteStubConverter(),\n  ]);\n  private llmClient?: LLMClient;\n  private history?: ProcessingHistory;\n\n  async onload() {\n    await this.loadSettings();\n\n    this.statusBarItem = this.addStatusBarItem();\n    this.updateStatus('Idle');\n    this.refreshLLMClient();\n    await this.refreshHistory();\n\n    this.addRibbonIcon('rotate-cw', 'Run NoteSync', () => void this.runSync());\n\n    this.addCommand({\n      id: 'notesync-sync-now',\n      name: 'Run NoteSync once',\n      callback: () => void this.runSync(),\n    });\n\n    this.addSettingTab(new NoteSyncSettingTab(this.app, this));\n\n    this.logger.onMessage((message) => this.updateStatus(message));\n    await this.restartWatcher();\n  }\n\n  async onunload() {\n    await this.stopWatcher();\n  }\n\n  private updateStatus(message: string) {\n    if (this.statusBarItem) {\n      this.statusBarItem.setText(`NoteSync: ${message}`);\n    }\n  }\n\n  async loadSettings() {\n    const stored = await this.loadData();\n    this.settings = Object.assign({}, DEFAULT_SETTINGS, stored ?? {});\n  }\n\n  async saveSettings() {\n    await this.saveData(this.settings);\n  }\n\n  async handleSettingsUpdated() {\n    await this.saveSettings();\n    await this.refreshHistory();\n    this.refreshLLMClient();\n    await this.restartWatcher();\n  }\n\n  private async refreshHistory() {\n    if (!this.settings.outputDir) {\n      this.history = undefined;\n      return;\n    }\n    const cacheDir = path.join(this.settings.outputDir, '.notesync-cache');\n    await ensureDir(cacheDir);\n    const historyPath = path.join(cacheDir, 'history.json');\n    if (this.history && this.history.filePath === historyPath) {\n      return;\n    }\n    this.history = new ProcessingHistory(historyPath);\n    await this.history.load();\n  }\n\n  private refreshLLMClient() {\n    try {\n      this.llmClient = createLLMClient({\n        provider: this.settings.llmProvider,\n        model: this.settings.llmModel,\n        apiKey: this.settings.apiKey,\n        endpoint: this.resolveApiEndpoint(),\n      });\n    } catch (error) {\n      console.error('Failed to create LLM client', error);\n      this.llmClient = undefined;\n    }\n  }\n\n  private resolveApiEndpoint() {\n    if (this.settings.llmProvider === 'ollama') {\n      return this.settings.apiEndpoint || 'http://localhost:11434';\n    }\n    return this.settings.apiEndpoint || 'https://api.openai.com/v1';\n  }\n\n  private async restartWatcher() {\n    await this.stopWatcher();\n\n    if (!this.settings.inputDir) {\n      this.logger.log('Set an input directory to enable watching');\n      return;\n    }\n\n    if (!existsSync(this.settings.inputDir)) {\n      this.logger.log('Input directory does not exist');\n      new Notice('NoteSync input directory missing. Update plugin settings.');\n      return;\n    }\n\n    this.watcher = chokidar.watch(this.settings.inputDir, {\n      ignoreInitial: true,\n      awaitWriteFinish: {\n        stabilityThreshold: 800,\n        pollInterval: 100,\n      },\n      persistent: true,\n    });\n\n    this.watcher\n      .on('add', (filePath) => this.handleFileEvent(filePath))\n      .on('change', (filePath) => this.handleFileEvent(filePath))\n      .on('error', (error) => this.logger.log(`Watcher error: ${error}`));\n\n    this.logger.log('Watching for handwritten notes');\n  }\n\n  private async stopWatcher() {\n    if (this.watcher) {\n      await this.watcher.close();\n      this.watcher = undefined;\n    }\n  }\n\n  private handleFileEvent(filePath: string) {\n    if (!this.isSupportedFile(filePath)) {\n      return;\n    }\n    this.queue.add(filePath);\n    this.logger.log(`Queued ${path.basename(filePath)}`);\n    if (this.settings.autoProcess) {\n      void this.processQueue();\n    }\n  }\n\n  private isSupportedFile(filePath: string) {\n    const converter = this.converterRegistry.getConverterForFile(filePath);\n    return Boolean(converter);\n  }\n\n  private async processQueue() {\n    if (this.processing) {\n      return;\n    }\n\n    this.processing = true;\n\n    try {\n      while (this.queue.size > 0) {\n        const next = this.queue.values().next().value as string | undefined;\n        if (!next) {\n          break;\n        }\n        this.queue.delete(next);\n        try {\n          await this.processSingleFile(next);\n        } catch (error) {\n          console.error(error);\n          this.logger.log(`Failed: ${path.basename(next)}`);\n          const message =\n            error instanceof Error ? error.message : String(error);\n          new Notice(`NoteSync failed for ${next}: ${message}`);\n        }\n      }\n      this.logger.log('Idle');\n    } finally {\n      this.processing = false;\n    }\n  }\n\n  private async processSingleFile(filePath: string) {\n    const converter = this.converterRegistry.getConverterForFile(filePath);\n    if (!converter) {\n      this.logger.log(`No converter registered for ${filePath}`);\n      return;\n    }\n\n    const context = await this.buildConversionContext();\n    const signature = await this.buildFileSignature(filePath);\n    if (!signature) {\n      this.logger.log(`Cannot read ${filePath}`);\n      return;\n    }\n\n    if (await this.shouldSkipFile(filePath, signature)) {\n      return;\n    }\n    this.logger.log(`Converting ${path.basename(filePath)}...`);\n    const images = await converter.convert(filePath, context);\n    if (!images.length) {\n      this.logger.log(`No PNGs produced for ${filePath}`);\n      return;\n    }\n\n    const encodedImages = await this.encodeImages(images);\n    const markdown = await this.generateMarkdown(encodedImages, {\n      fileName: path.basename(filePath),\n      promptPrefix: this.settings.promptPrefix,\n    });\n    const outputPath = await this.writeMarkdownFile(filePath, markdown);\n    await this.recordProcessedFile(filePath, signature, outputPath);\n    this.logger.log(`Finished ${path.basename(filePath)}`);\n    new Notice(`NoteSync finished ${path.basename(filePath)}`);\n  }\n\n  private async buildConversionContext(): Promise<ConversionContext> {\n    if (!this.settings.inputDir || !this.settings.outputDir) {\n      throw new Error('Please configure input and output directories in NoteSync settings.');\n    }\n\n    const cacheDir = path.join(this.settings.outputDir, '.notesync-cache');\n    await ensureDir(cacheDir);\n\n    return {\n      inputDir: this.settings.inputDir,\n      outputDir: this.settings.outputDir,\n      cacheDir,\n      maxImageWidth: this.settings.maxImageWidth,\n      logger: (message: string) => this.logger.log(message),\n    };\n  }\n\n  private async encodeImages(images: ConvertedImage[]): Promise<EncodedImage[]> {\n    const payload: EncodedImage[] = [];\n    for (const image of images) {\n      const buffer = await fs.readFile(image.path);\n      payload.push({\n        data: buffer.toString('base64'),\n        mediaType: 'image/png',\n        page: image.page,\n      });\n    }\n    return payload;\n  }\n\n  private async generateMarkdown(images: EncodedImage[], context: LLMGenerationContext) {\n    if (!this.llmClient) {\n      this.refreshLLMClient();\n    }\n    if (!this.llmClient) {\n      throw new Error('LLM client not configured. Check provider settings.');\n    }\n    this.logger.log('Sending to language model...');\n    return this.llmClient.generateMarkdown(images, context);\n  }\n\n  private async writeMarkdownFile(originalFile: string, markdown: string) {\n    const relativePath = path.relative(this.settings.inputDir, originalFile);\n    const baseName = path.basename(relativePath, path.extname(relativePath));\n    const targetDir = path.join(\n      this.settings.outputDir,\n      path.dirname(relativePath)\n    );\n    await ensureDir(targetDir);\n    const outputPath = path.join(targetDir, `${baseName}.md`);\n    const header = `---\\nsource: ${originalFile}\\nprocessed: ${new Date().toISOString()}\\n---\\n\\n`;\n    await fs.writeFile(outputPath, `${header}${markdown}\\n`, 'utf8');\n    return outputPath;\n  }\n\n  private async buildFileSignature(filePath: string): Promise<FileSignature | undefined> {\n    try {\n      const stats = await fs.stat(filePath);\n      return { size: stats.size, mtimeMs: stats.mtimeMs };\n    } catch (error) {\n      console.warn('Unable to stat file', filePath, error);\n      return undefined;\n    }\n  }\n\n  private async shouldSkipFile(filePath: string, signature: FileSignature) {\n    if (!this.history) {\n      return false;\n    }\n    const relative = path.relative(this.settings.inputDir, filePath);\n    if (this.history.isSame(relative, signature)) {\n      this.logger.log(`Skipping ${path.basename(filePath)} (unchanged)`);\n      return true;\n    }\n    return false;\n  }\n\n  private async recordProcessedFile(\n    filePath: string,\n    signature: FileSignature,\n    outputPath: string\n  ) {\n    if (!this.history) {\n      return;\n    }\n    const relative = path.relative(this.settings.inputDir, filePath);\n    await this.history.record(relative, signature, outputPath);\n  }\n\n  private async runSync() {\n    try {\n      await this.validateDirectories();\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      new Notice(message);\n      return;\n    }\n\n    this.logger.log('Scanning for files...');\n    await this.collectExistingFiles(this.settings.inputDir);\n    await this.processQueue();\n  }\n\n  private async validateDirectories() {\n    if (!this.settings.inputDir || !existsSync(this.settings.inputDir)) {\n      throw new Error('Input directory missing or invalid');\n    }\n    if (!this.settings.outputDir) {\n      throw new Error('Output directory is not configured');\n    }\n    await ensureDir(this.settings.outputDir);\n  }\n\n  private async collectExistingFiles(dir: string) {\n    let entries;\n    try {\n      entries = await fs.readdir(dir, { withFileTypes: true });\n    } catch (error) {\n      console.warn('Unable to read directory', dir, error);\n      return;\n    }\n    for (const entry of entries) {\n      const fullPath = path.join(dir, entry.name);\n      if (entry.isDirectory()) {\n        await this.collectExistingFiles(fullPath);\n        continue;\n      }\n      if (this.isSupportedFile(fullPath)) {\n        this.queue.add(fullPath);\n      }\n    }\n  }\n}\n", "import path from 'path';\nimport type { NoteConverter } from './types';\n\nexport class ConverterRegistry {\n  private converters: NoteConverter[] = [];\n\n  constructor(converters: NoteConverter[] = []) {\n    this.converters = converters;\n  }\n\n  register(converter: NoteConverter) {\n    this.converters.push(converter);\n  }\n\n  getConverterForFile(filePath: string) {\n    const ext = path.extname(filePath).toLowerCase().replace('.', '');\n    return this.converters.find((converter) =>\n      converter.supportedExtensions.includes(ext)\n    );\n  }\n\n  getSupportedExtensions() {\n    const extensions = new Set<string>();\n    this.converters.forEach((converter) =>\n      converter.supportedExtensions.forEach((ext) => extensions.add(ext))\n    );\n    return Array.from(extensions.values());\n  }\n}\n", "import path from 'path';\nimport sharp from 'sharp';\nimport type { ConvertedImage, NoteConverter } from './types';\nimport type { ConversionContext } from './types';\nimport { ensureDir, scaleImageFile } from './utils';\n\nexport class PdfConverter implements NoteConverter {\n  readonly supportedExtensions = ['pdf'];\n\n  async convert(filePath: string, context: ConversionContext): Promise<ConvertedImage[]> {\n    const metadata = await sharp(filePath, { pages: 1 }).metadata();\n    const pages = metadata.pages ?? 1;\n\n    if (!pages || pages < 1) {\n      throw new Error('PDF has no pages');\n    }\n\n    const relPath = path.relative(context.inputDir, filePath);\n    const relDir = path.dirname(relPath);\n    const baseName = path.basename(filePath, path.extname(filePath));\n    const outputDir = path.join(context.cacheDir, relDir);\n    await ensureDir(outputDir);\n\n    const images: ConvertedImage[] = [];\n\n    for (let page = 0; page < pages; page += 1) {\n      const pngPath = path.join(outputDir, `${baseName}-page-${page + 1}.png`);\n      await sharp(filePath, { page, density: 240 }).png().toFile(pngPath);\n      await scaleImageFile(pngPath, context.maxImageWidth);\n      images.push({ path: pngPath, page: page + 1 });\n    }\n\n    context.logger(`PDF converted to ${images.length} PNG file(s)`);\n    return images;\n  }\n}\n", "import fs from 'fs/promises';\nimport path from 'path';\nimport sharp from 'sharp';\n\nexport async function ensureDir(dirPath: string) {\n  await fs.mkdir(dirPath, { recursive: true });\n}\n\nexport async function scaleImageFile(filePath: string, maxWidth?: number) {\n  if (!maxWidth || maxWidth <= 0) {\n    return;\n  }\n\n  const metadata = await sharp(filePath).metadata();\n  if (!metadata.width || metadata.width <= maxWidth) {\n    return;\n  }\n\n  const tempPath = buildTempPath(filePath);\n  await sharp(filePath)\n    .resize({ width: maxWidth, withoutEnlargement: true })\n    .toFile(tempPath);\n  await fs.rename(tempPath, filePath);\n}\n\nfunction buildTempPath(originalPath: string) {\n  const dir = path.dirname(originalPath);\n  const base = path.basename(originalPath);\n  return path.join(dir, `.tmp-${base}`);\n}\n", "import { NoteConverter, ConvertedImage, ConversionContext } from './types';\n\nexport class NoteStubConverter implements NoteConverter {\n  readonly supportedExtensions = ['note'];\n\n  async convert(filePath: string, context: ConversionContext): Promise<ConvertedImage[]> {\n    context.logger(`.note conversion not implemented yet for ${filePath}`);\n    return [];\n  }\n}\n", "export type Logger = (message: string) => void;\n\nexport class StatusLogger {\n  private history: { timestamp: number; message: string }[] = [];\n  private listeners: Array<(message: string) => void> = [];\n\n  log(message: string) {\n    const item = { timestamp: Date.now(), message };\n    this.history.push(item);\n    if (this.history.length > 100) {\n      this.history.shift();\n    }\n    this.listeners.forEach((listener) => listener(message));\n  }\n\n  onMessage(listener: (message: string) => void) {\n    this.listeners.push(listener);\n    return () => {\n      this.listeners = this.listeners.filter((fn) => fn !== listener);\n    };\n  }\n\n  getHistory(limit = 20) {\n    return this.history.slice(-limit);\n  }\n}\n", "import { App, PluginSettingTab, Setting } from 'obsidian';\nimport type NoteSyncPlugin from './main';\nimport type { LLMProvider } from './llm';\n\nexport interface NoteSyncSettings {\n  inputDir: string;\n  outputDir: string;\n  llmProvider: LLMProvider;\n  llmModel: string;\n  apiKey: string;\n  apiEndpoint: string;\n  maxImageWidth: number;\n  promptPrefix: string;\n  autoProcess: boolean;\n}\n\nexport const DEFAULT_SETTINGS: NoteSyncSettings = {\n  inputDir: '',\n  outputDir: '',\n  llmProvider: 'openai',\n  llmModel: 'gpt-4o-mini',\n  apiKey: '',\n  apiEndpoint: 'https://api.openai.com/v1',\n  maxImageWidth: 1800,\n  promptPrefix: '',\n  autoProcess: true,\n};\n\nexport class NoteSyncSettingTab extends PluginSettingTab {\n  constructor(app: App, private readonly plugin: NoteSyncPlugin) {\n    super(app, plugin);\n  }\n\n  display(): void {\n    const { containerEl } = this;\n    containerEl.empty();\n\n    containerEl.createEl('h2', { text: 'NoteSync Settings' });\n\n    new Setting(containerEl)\n      .setName('Input directory')\n      .setDesc('Absolute path to where handwritten note files appear')\n      .addText((text) =>\n        text\n          .setPlaceholder('/Users/me/Scans')\n          .setValue(this.plugin.settings.inputDir)\n          .onChange(async (value) => {\n            this.plugin.settings.inputDir = value.trim();\n            await this.plugin.handleSettingsUpdated();\n          })\n      );\n\n    new Setting(containerEl)\n      .setName('Output directory')\n      .setDesc('Markdown files and generated PNGs will be stored here (mirrors sub-folders)')\n      .addText((text) =>\n        text\n          .setPlaceholder('/Users/me/Obsidian/Inbox')\n          .setValue(this.plugin.settings.outputDir)\n          .onChange(async (value) => {\n            this.plugin.settings.outputDir = value.trim();\n            await this.plugin.handleSettingsUpdated();\n          })\n      );\n\n    new Setting(containerEl)\n      .setName('LLM provider')\n      .addDropdown((dropdown) =>\n        dropdown\n          .addOptions({ openai: 'OpenAI', ollama: 'Ollama (local)' })\n          .setValue(this.plugin.settings.llmProvider)\n          .onChange(async (value) => {\n            this.plugin.settings.llmProvider = value as LLMProvider;\n            if (value === 'ollama' && !this.plugin.settings.apiEndpoint) {\n              this.plugin.settings.apiEndpoint = 'http://localhost:11434';\n            }\n            if (value === 'openai' && !this.plugin.settings.apiEndpoint) {\n              this.plugin.settings.apiEndpoint = 'https://api.openai.com/v1';\n            }\n            await this.plugin.handleSettingsUpdated();\n            this.display();\n          })\n      );\n\n    if (this.plugin.settings.llmProvider === 'openai') {\n      new Setting(containerEl)\n        .setName('OpenAI API key')\n        .setDesc('Stored locally only. Required for OpenAI provider.')\n        .addText((text) =>\n          text\n            .setPlaceholder('sk-...')\n            .setValue(this.plugin.settings.apiKey)\n            .onChange(async (value) => {\n              this.plugin.settings.apiKey = value.trim();\n              await this.plugin.handleSettingsUpdated();\n            })\n        );\n\n      new Setting(containerEl)\n        .setName('OpenAI base URL (optional)')\n        .setDesc('Override when using a compatible proxy endpoint.')\n        .addText((text) =>\n          text\n            .setPlaceholder('https://api.openai.com/v1')\n            .setValue(this.plugin.settings.apiEndpoint)\n            .onChange(async (value) => {\n              this.plugin.settings.apiEndpoint = value.trim();\n              await this.plugin.handleSettingsUpdated();\n            })\n        );\n    } else {\n      new Setting(containerEl)\n        .setName('Ollama endpoint')\n        .setDesc('Defaults to http://localhost:11434')\n        .addText((text) =>\n          text\n            .setPlaceholder('http://localhost:11434')\n            .setValue(this.plugin.settings.apiEndpoint || 'http://localhost:11434')\n            .onChange(async (value) => {\n              this.plugin.settings.apiEndpoint = value.trim();\n              await this.plugin.handleSettingsUpdated();\n            })\n        );\n    }\n\n    new Setting(containerEl)\n      .setName('Model')\n      .setDesc('Model identifier for the selected provider')\n      .addText((text) =>\n        text\n            .setPlaceholder('gpt-4o-mini')\n            .setValue(this.plugin.settings.llmModel)\n            .onChange(async (value) => {\n              this.plugin.settings.llmModel = value.trim();\n              await this.plugin.handleSettingsUpdated();\n            })\n      );\n\n    new Setting(containerEl)\n      .setName('Maximum image width (px)')\n      .setDesc('PNG pages wider than this will be scaled down to save tokens (0 disables scaling)')\n      .addText((text) =>\n        text\n          .setPlaceholder('1800')\n          .setValue(String(this.plugin.settings.maxImageWidth))\n          .onChange(async (value) => {\n            const parsed = Number(value);\n            this.plugin.settings.maxImageWidth = Number.isNaN(parsed) ? 0 : parsed;\n            await this.plugin.saveSettings();\n          })\n      );\n\n    new Setting(containerEl)\n      .setName('Prompt helper')\n      .setDesc('Optional instruction prepended to every transcription request')\n      .addTextArea((text) =>\n        text\n          .setPlaceholder('Emphasize TODO extraction...')\n          .setValue(this.plugin.settings.promptPrefix)\n          .onChange(async (value) => {\n            this.plugin.settings.promptPrefix = value;\n            await this.plugin.saveSettings();\n          })\n      );\n\n    new Setting(containerEl)\n      .setName('Auto process new files')\n      .setDesc('If disabled, files are only processed when you hit the Sync button/command')\n      .addToggle((toggle) =>\n        toggle\n          .setValue(this.plugin.settings.autoProcess)\n          .onChange(async (value) => {\n            this.plugin.settings.autoProcess = value;\n            await this.plugin.saveSettings();\n          })\n      );\n  }\n}\n", "import { EncodedImage, LLMClient, LLMGenerationContext } from './types';\n\ninterface OllamaConfig {\n  endpoint?: string;\n  model: string;\n}\n\nconst DEFAULT_OLLAMA_URL = 'http://localhost:11434';\n\nexport class OllamaLLMClient implements LLMClient {\n  constructor(private readonly config: OllamaConfig) {}\n\n  async generateMarkdown(images: EncodedImage[], context: LLMGenerationContext): Promise<string> {\n    const endpoint = (this.config.endpoint || DEFAULT_OLLAMA_URL).replace(/\\/$/, '');\n    const promptInstruction =\n      context.promptPrefix ??\n      'Transcribe and summarize the handwritten content into Markdown. Keep the note structure intact.';\n\n    const payload = {\n      model: this.config.model || 'llama3.2-vision',\n      prompt: `${promptInstruction}\\nFile name: ${context.fileName}`,\n      images: images.map((image) => image.data),\n      stream: false,\n    };\n\n    const response = await fetch(`${endpoint}/api/generate`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(payload),\n    });\n\n    if (!response.ok) {\n      const message = await response.text();\n      throw new Error(`Ollama request failed: ${response.status} ${message}`);\n    }\n\n    const data = await response.json();\n    return (data.response ?? '').trim();\n  }\n}\n", "import { EncodedImage, LLMClient, LLMGenerationContext } from './types';\n\ninterface OpenAIConfig {\n  apiKey: string;\n  model: string;\n  baseUrl?: string;\n}\n\nconst DEFAULT_OPENAI_URL = 'https://api.openai.com/v1';\n\nexport class OpenAILLMClient implements LLMClient {\n  constructor(private readonly config: OpenAIConfig) {}\n\n  async generateMarkdown(images: EncodedImage[], context: LLMGenerationContext) {\n    if (!this.config.apiKey) {\n      throw new Error('OpenAI API key missing');\n    }\n\n    const prompt =\n      context.promptPrefix ??\n      'Extract the handwritten note content, structure it with Markdown headings when appropriate, and keep bullet/numbered lists intact.';\n\n    const content = [\n      {\n        type: 'text',\n        text: `${prompt}\\nFile name: ${context.fileName}`,\n      },\n      ...images.map((image) => ({\n        type: 'image_url',\n        image_url: {\n          url: `data:${image.mediaType};base64,${image.data}`,\n        },\n      })),\n    ];\n\n    const body = {\n      model: this.config.model || 'gpt-4o-mini',\n      messages: [\n        {\n          role: 'system',\n          content:\n            'You convert handwritten note images to clean Markdown. Preserve equations and transcribe diagrams descriptively when possible.',\n        },\n        {\n          role: 'user',\n          content,\n        },\n      ],\n      temperature: 0.2,\n    };\n\n    const response = await fetch(`${this.config.baseUrl ?? DEFAULT_OPENAI_URL}/chat/completions`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${this.config.apiKey}`,\n      },\n      body: JSON.stringify(body),\n    });\n\n    if (!response.ok) {\n      const message = await response.text();\n      throw new Error(`OpenAI request failed: ${response.status} ${message}`);\n    }\n\n    const payload = await response.json();\n    const choice = payload.choices?.[0]?.message?.content;\n    if (Array.isArray(choice)) {\n      return choice\n        .map((piece: { type?: string; text?: string }) => piece.text ?? '')\n        .join('\\n')\n        .trim();\n    }\n    return (choice ?? '').trim();\n  }\n}\n", "import { OllamaLLMClient } from './ollamaClient';\nimport { OpenAILLMClient } from './openaiClient';\nimport { LLMClient } from './types';\n\nexport type LLMProvider = 'openai' | 'ollama';\n\nexport interface LLMConfiguration {\n  provider: LLMProvider;\n  model: string;\n  apiKey?: string;\n  endpoint?: string;\n}\n\nexport const createLLMClient = (config: LLMConfiguration): LLMClient => {\n  if (config.provider === 'ollama') {\n    return new OllamaLLMClient({ endpoint: config.endpoint, model: config.model });\n  }\n\n  return new OpenAILLMClient({\n    apiKey: config.apiKey ?? '',\n    model: config.model,\n    baseUrl: config.endpoint,\n  });\n};\n\nexport * from './types';\n", "import fs from 'fs/promises';\nimport path from 'path';\nimport { ensureDir } from './conversion';\n\nexport interface FileSignature {\n  size: number;\n  mtimeMs: number;\n}\n\nexport interface FileRecord {\n  signature: FileSignature;\n  processedAt: string;\n  outputPath: string;\n}\n\nexport class ProcessingHistory {\n  private data = new Map<string, FileRecord>();\n  readonly filePath: string;\n\n  constructor(filePath: string) {\n    this.filePath = filePath;\n  }\n\n  async load() {\n    try {\n      const content = await fs.readFile(this.filePath, 'utf8');\n      const parsed = JSON.parse(content) as Record<string, FileRecord>;\n      this.data = new Map(Object.entries(parsed));\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        this.data.clear();\n        return;\n      }\n      console.warn('Failed to load NoteSync history', error);\n      this.data.clear();\n    }\n  }\n\n  getRecord(relativePath: string) {\n    return this.data.get(relativePath);\n  }\n\n  isSame(relativePath: string, signature: FileSignature) {\n    const record = this.data.get(relativePath);\n    if (!record) {\n      return false;\n    }\n    return (\n      record.signature.size === signature.size &&\n      Math.abs(record.signature.mtimeMs - signature.mtimeMs) < 1\n    );\n  }\n\n  async record(relativePath: string, signature: FileSignature, outputPath: string) {\n    this.data.set(relativePath, {\n      signature,\n      processedAt: new Date().toISOString(),\n      outputPath,\n    });\n    await this.save();\n  }\n\n  private async save() {\n    const dir = path.dirname(this.filePath);\n    await ensureDir(dir);\n    const object = Object.fromEntries(this.data.entries());\n    await fs.writeFile(this.filePath, JSON.stringify(object, null, 2), 'utf8');\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_obsidian", "import_path", "fs", "path", "import_path", "import_sharp", "import_path", "fs", "sharp", "path", "sharp", "path", "import_promises", "import_path", "fs", "path", "path", "chokidar"]
}
